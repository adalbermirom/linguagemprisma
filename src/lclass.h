/* WARNING: This file was automatically generated by lua2c. */
/* Conversão classe para C lbaselib.c Prisma 1.1.0 maio 2018*/
#ifdef __cplusplus
extern "C" {
#endif
#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* name: search
 * function( k , plist) */
static int lcf1_search (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* for i = 1 , #plist do */
  lua_pushnumber(L,1);
  lua_len(L,2);
  if (!((lua_isnumber(L,-2) && lua_isnumber(L,-1)))) {
    luaL_error(L,"limite 'para' deve ser um número");
  }
  double lc2_var = lua_tonumber(L,-2);
  const double lc3_limit = lua_tonumber(L,-1);
  const double lc4_step = 1;
  lua_pop(L,2);
  enum { lc6 = 2 };
  while ((((lc4_step > 0) && (lc2_var <= lc3_limit)) || ((lc4_step <= 0) && (lc2_var >= lc3_limit)))) {
    
    /* internal: local i at index 3 */
    lua_pushnumber(L,lc2_var);
    
    /* local v = plist[i][k] */
    lua_pushvalue(L,3);
    lua_gettable(L,2);
    lua_pushvalue(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 4);
    
    /* if v then */
    enum { lc7 = 4 };
    if (lua_toboolean(L,4)) {
      
      /* return v */
      lua_pushvalue(L,4);
      return 1;
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc7);
    assert(lua_gettop(L) == 4);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
    lc2_var += lc4_step;
  }
  lua_settop(L,lc6);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: c:novo
 * function( o) */
static int lcf1_c_novo (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* o = o or {} */
  lua_pushvalue(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_newtable(L);
  }
  lua_replace(L,2);
  assert(lua_gettop(L) == 2);
  
  /* setmetatable( o , c ) */
  lua_getglobal(L,"defmetatabela");
  lua_pushvalue(L,2);
  lc_getupvalue(L,lua_upvalueindex(1),1,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 2);
  
  /* return o */
  lua_pushvalue(L,2);
  return 1;
  assert(lua_gettop(L) == 2);
}


/* function( t , k) */
static int lcf12 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* return search ( k , parents ) */
  const int lc11 = lua_gettop(L);
  lc_getupvalue(L,lua_upvalueindex(1),2,1);
  lua_pushvalue(L,2);
  lc_getupvalue(L,lua_upvalueindex(1),0,3);
  lua_call(L,2,LUA_MULTRET);
  return (lua_gettop(L) - lc11);
  assert(lua_gettop(L) == 2);
}


/* function(self,...) */
static int lcf14 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  if ((lua_gettop(L) < lc_nformalargs)) {
    lua_settop(L,lc_nformalargs);
  }
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local obj = self:novo() */
  lua_pushvalue(L,1);
  lua_pushliteral(L,"novo");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* obj:construtor(...) */
  lua_pushvalue(L,(2 + lc_nextra));
  const int lc13 = lua_gettop(L);
  lua_pushliteral(L,"construtor");
  lua_gettable(L,-2);
  if(!lua_isfunction(L, -1) ) {
		lua_pushliteral(L, " Metodo construtor() da Classe nao definido ou invalido.\nDefina-o: funcao class:construtor() ... fim");
		lua_error(L);
	}
  lua_insert(L,-2);
  {int i; for (i=lc_nformalargs+1; i<=lc_nactualargs; i++) { lua_pushvalue(L, i); }}
  lua_call(L,(lua_gettop(L) - lc13),0);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* return obj */
  lua_pushvalue(L,(2 + lc_nextra));
  return 1;
  assert(lua_gettop(L) - lc_nextra == 2);
}


/* name: Classe
 * function(...) */
static int lcf1_Classe (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local c = {} */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc8 = 1 };
  assert((lua_gettop(L) == (lc8 + lc_nextra)));
  lua_newtable(L);
  lua_rawseti(L,(lc8 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local parents = {...} */
  lc_newclosuretable(L,(lc8 + lc_nextra));
  enum { lc9 = 2 };
  assert((lua_gettop(L) == (lc9 + lc_nextra)));
  lua_createtable(L,1,0);
  const int lc10 = lua_gettop(L);
  {int i; for (i=lc_nformalargs+1; i<=lc_nactualargs; i++) { lua_pushvalue(L, i); }}
  while ((lua_gettop(L) > lc10)) {
    lua_rawseti(L,lc10,(0 + (lua_gettop(L) - lc10)));
  }
  lua_rawseti(L,(lc9 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* function c:novo ( o )
   *         o = o or {}
   *         setmetatable( o , c );
   *         return o 
   *     end */
  lua_pushvalue(L,(lc9 + lc_nextra));
  lua_pushcclosure(L,lcf1_c_novo,1);
  lc_getupvalue(L,(lc9 + lc_nextra),1,2);
  lua_insert(L,-2);
  lua_pushliteral(L,"novo");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* setmetatable ( c , { __index = function( t , k )
   *        return search ( k , parents )
   *        end;
   *        __call = function(self,...) 
   *                   local obj = self:novo();
   *                   obj:construtor(...);
   *                   return obj;
   *                end}  ) */
  lua_getglobal(L,"defmetatabela");
  lc_getupvalue(L,(lc9 + lc_nextra),1,2);
  lua_createtable(L,0,2);
  lua_pushliteral(L,"__index");
  lua_pushvalue(L,(lc9 + lc_nextra));
  lua_pushcclosure(L,lcf12,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"__call");
  lua_pushcfunction(L,lcf14);
  lua_rawset(L,-3);
  lua_call(L,2,0);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* c.__index = c */
  lc_getupvalue(L,(lc9 + lc_nextra),1,2);
  lc_getupvalue(L,(lc9 + lc_nextra),1,2);
  lua_insert(L,-2);
  lua_pushliteral(L,"__index");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* return c */
  lc_getupvalue(L,(lc9 + lc_nextra),1,2);
  return 1;
  assert(lua_gettop(L) - lc_nextra == 2);
}


/* name: (main)
 * function(...) */
static int lcf_classe (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local function search ( k , plist )
   *      for i = 1 , #plist do
   *          local v = plist[i][k]
   *          if v then return v end
   *      end
   * end */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_pushcfunction(L,lcf1_search);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* function Classe(...)
   *     local c = {} ;
   *     local parents = {...};
   *     
   *     function c:novo ( o )
   *         o = o or {}
   *         setmetatable( o , c );
   *         return o 
   *     end
   *     
   *     setmetatable ( c , { __index = function( t , k )
   *        return search ( k , parents )
   *        end;
   *        __call = function(self,...) 
   *                   local obj = self:novo();
   *                   obj:construtor(...);
   *                   return obj;
   *                end}  );
   *  
   *     c.__index = c;
   *          
   *    return c;
   * end */
  lua_pushvalue(L,(lc1 + lc_nextra));
  lua_pushcclosure(L,lcf1_Classe,1);
  lua_setglobal(L,"Classe");
  assert(lua_gettop(L) - lc_nextra == 1);
  lua_pop(L,1);/*retirando da pilha*/
  return 0;
}



