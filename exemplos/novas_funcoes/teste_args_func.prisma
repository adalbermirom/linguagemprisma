/*

 Um ponto fraco em Lua e Prisma é que não podemos definir o tipo das variáveis, pois a tipagem é 
dinâmica.
 Por um lado, isso pode parecer vantajoso, mas em um programa grande pode se tornar um temor
 procurar por um erro de tipagem em plena execução.
 * 

  Uma maneira que encontrei para amenizar esse problema foi criar funções para checagem de tipo, 
  forçando um erro caso o tipo não seja o esperado.
  
  Fica, é claro, a cargo do programador implementar um programa com checagem ou não.
  
  Podemos, agora, por exemplo, verificar o tipo de string:
      
      local nome_cliente = S( obtenha_nome_cliente(1) ); //garantimmos que o valor seja uma strig.
      * 
     
     
     Veja os exemplos abaixo: 
 
*/ 
 

funcao soma(a,b)
    local a, b = N(a,b);//se a ou b não for número, então ocorrerá um erro, o programa será fechado.
    retorne N(a+b); //garantindo que o retorno seja um número válido.
fim


local tab_clientes = {'José', 'Maria', 'Stefanie', 'Adriano', 'Ronaldo', 'Ramiro', 'Laura','Kamila'};
funcao obtenha_nome_cliente(n)
    local n = N(n); //garantindo que 'n' seja um número válido.
    local clientes = T(tab_clientes); //verifica se tab_clientes é uma tabela
    retorne S(clientes[n]); //garantindo que o retorno seja uma string.
fim

funcao principal()
    imprima('soma 1+3:', N(soma(1,3)) );
    imprima( 'Nome cliente index[2]:', S(obtenha_nome_cliente(2)) );
    
    //Testando vários tipos:
    local t = T({'um','dois','três'}); //T() ou Tab() mesma função
    local s = S('Uma string qualquer'); //S() ou Str();
    local n = N(12); //N() ou Num();
    local b = B(falso); //B() ou Bool();
    local func = F(imprima); //F() ou Func();
    local v1 = Val('numero', 98);
    //podemos testar mais de um valor por vez, nas funções acima:
    
    //números:
    poe'\n\n:::::::::::::::::::\n';
    local t = {N(1,2,3,4)};//colocamos todos os retornos de N() direto em uma tabela.
    para i,v em ipares(t) inicio //imprimimos todos os valores da tabela:
        imprima(i, N(v));
    fim
    
    poe'\n\n:::::::::::::::::::\n';
    imprima('t', t);
    imprima('s:', s);
    imprima('n:', n);
    imprima('bool:', b);
    imprima('func:', func);
    imprima('v1:', v1);
    
    /*há também as funções Thre() para co rotinas e Udat() ou U() para userdata */
    
    
    
    //forçando erros: (retire as barras de comentário para ver cada erro)
   // soma(1,'a');//espera-se número em vez de string em arg#2;
    
    //imprima( obtenha_nome_cliente(10) );//como não há o indice 10 na tabela tab_clientes, o retorno 
                                        //é nulo e gera um erro, pois espera-se uma string.
    
    retorne 0;
fim






